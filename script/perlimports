#!perl

# Does not work with modules using Sub::Exporter

use strict;
use warnings;

use FindBin qw( $Bin );
use lib "$Bin/../lib";

use App::perlimports ();
use Getopt::Long::Descriptive qw( describe_options );
use Path::Tiny qw( path );
use Pod::Usage qw( pod2usage );

my ( $opt, $usage ) = describe_options(
    'perlimports %o <some-arg>',
    [ 'filename|f=s', 'the file containing the imports', { required => 1 } ],
    [ 'inplace-edit|i', 'edit the file in place' ],
    [
        'libs|=s',
        'comma-separated list of library paths to include (eg --libs lib,t/lib,dev/lib)',

    ],
    [ 'read-stdin', 'read statements to process from STDIN rather than the supplied file', ],
    [],
    [ 'help', "print usage message and exit", { shortcircuit => 1 } ],
);

if ( $opt->help ) {
    print $usage->text;
    print pod2usage();
    exit;
}

my $input;

if ( $opt->read_stdin ) {
    local $/;
    $input = <STDIN>;
}
else {
    $input = path( $opt->filename )->slurp;
}

my $doc = PPI::Document->new( \$input );

my $includes = $doc->find(
    sub {
        $_[1]->isa('PPI::Statement::Include');
    }
);

foreach my $include ( @{$includes} ) {
    my $e = App::perlimports->new(
        filename => $opt->filename,
        include  => $include,
        $opt->libs ? ( libs => [ split m{,}, $opt->libs ] ) : (),
    );

    my $elem = $e->formatted_ppi_statement;

    # https://github.com/adamkennedy/PPI/issues/189
    $include->insert_before( $elem->clone );
    $include->remove;
}

# We need to do this in order to preserve HEREDOCs.
# See https://metacpan.org/pod/PPI::Document#serialize
my $serialized = $doc->serialize;

if ( $opt->read_stdin ) {
    print $serialized;
}
elsif ( $opt->inplace_edit ) {
    path( $opt->filename )->spew($serialized);
}
else {
    print $serialized;
}

exit(0);

# PODNAME: perlimports
# ABSTRACT: A command line utility for cleaning up imports in your Perl code

=pod

=head1 SYNOPSIS

Update a file in place. (Make sure you can revert the file if you need to.)

    perlimports --filename test-data/foo.pl --inplace-edit

If some of your imported modules are in local directories, you can give some
hints as to where to find them:

    perlimports --filename test-data/foo.pl --inplace-edit --libs t/lib,/some/dir/lib

Redirect output to a new file:

    perlimports --filename test-data/foo.pl > foo.new.pl

=head2 VIM

If you're a C<vim> user, you can pipe your import statements to perlimports directly.

    :vnoremap <silent> im :!perlimports --read-stdin --filename '%:p'<CR>

The above statement will allow you to visually select one or more lines of code
and have them updated in place by C<perlimports>. Once you have selected the
code enter C<im> to have your imports (re)formatted.
