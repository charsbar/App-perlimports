#!perl

# Does not work with modules using Sub::Exporter

use strict;
use warnings;

use FindBin qw( $Bin );
use lib "$Bin/../lib";

use App::perlimports ();
use Data::Printer;
use Getopt::Long::Descriptive qw( describe_options );
use List::Util qw( uniq );
use Path::Tiny qw( path );
use Pod::Usage qw( pod2usage );
use Try::Catch qw( catch try );

my ( $opt, $usage ) = describe_options(
    'perlimports %o <some-arg>',
    [ 'filename|f=s', 'the file containing the imports', { required => 1 } ],
    [
        'ignored-modules=s',
        'comma-seperated list of modules to ignore (eg --ignored-modules Test::More,Test::Most'
    ],
    [
        'ignored-modules-filename=s',
        'file containing list of modules to ignore. One module per line.'
    ],
    [ 'inplace-edit|i', 'edit the file in place' ],
    [
        'libs=s',
        'comma-seperated list of library paths to include (eg --libs lib,t/lib,dev/lib)',

    ],
    [
        'read-stdin',
        'read statements to process from STDIN rather than the supplied file',
    ],
    [],
    [ 'verbose|v', 'print errors to STDERR' ],
    [ 'help', "print usage message and exit", { shortcircuit => 1 } ],
);

if ( $opt->help ) {
    print $usage->text;
    print pod2usage();
    exit;
}

my $input;

if ( $opt->read_stdin ) {
    local $/;
    $input = <STDIN>;
}
else {
    $input = path( $opt->filename )->slurp;
}

my $doc = PPI::Document->new( \$input );

my $includes = $doc->find(
    sub {
        $_[1]->isa('PPI::Statement::Include');
    }
) || [];

if ( $opt->libs ) {
    unshift @INC, ( split m{,}, $opt->libs );
}

my @ignored_modules
    = $opt->ignored_modules
    ? split m{,}, $opt->ignored_modules
    : ();

if ( $opt->ignored_modules_filename ) {
    my @from_file
        = path( $opt->ignored_modules_filename )->lines( { chomp => 1 } );
    @ignored_modules = uniq( @ignored_modules, @from_file );
}

my %base_args = (
    filename => $opt->filename,
    @ignored_modules
    ? ( ignored_modules => \@ignored_modules )
    : (),
    $opt->libs
    ? ( libs => [ split m{,}, $opt->libs ] )
    : (),
);

foreach my $include ( @{$includes} ) {
    my $e = App::perlimports->new(
        %base_args,
        include => $include,
    );

    my $elem;
    try {
        $elem = $e->formatted_ppi_statement;
    }
    catch {
        print STDERR 'Error: ' . $opt->filename . "\n";
        print STDERR $include;
        print STDERR $_;
    };

    next unless $elem;

    # https://github.com/adamkennedy/PPI/issues/189
    $include->insert_before( $elem->clone );
    $include->remove;

    if ( $opt->verbose && $e->has_errors ) {
        print STDERR 'Error: ' . $opt->filename . "\n";
        print STDERR $e->_module_name . ' ' . np( $e->errors ) . "\n";
    }
}

# We need to do this in order to preserve HEREDOCs.
# See https://metacpan.org/pod/PPI::Document#serialize
my $serialized = $doc->serialize;

if ( $opt->read_stdin ) {
    print $serialized;
}
elsif ( $opt->inplace_edit ) {
    path( $opt->filename )->spew($serialized);
}
else {
    print $serialized;
}

exit(0);

# PODNAME: perlimports
# ABSTRACT: A command line utility for cleaning up imports in your Perl code

=pod

=head1 SYNOPSIS

Update a file in place. (Make sure you can revert the file if you need to.)

    perlimports --filename test-data/foo.pl --inplace-edit

If some of your imported modules are in local directories, you can give some
hints as to where to find them:

    perlimports --filename test-data/foo.pl --inplace-edit --libs t/lib,/some/dir/lib

Redirect output to a new file:

    perlimports --filename test-data/foo.pl > foo.new.pl

=head2 VIM

If you're a C<vim> user, you can pipe your import statements to perlimports directly.

    :vnoremap <silent> im :!perlimports --read-stdin --filename '%:p'<CR>

The above statement will allow you to visually select one or more lines of code
and have them updated in place by C<perlimports>. Once you have selected the
code enter C<im> to have your imports (re)formatted.
