#!perl

use strict;
use warnings;

use FindBin qw( $Bin );
use lib "$Bin/../lib";

use App::perlimports           ();
use App::perlimports::Document ();
use Data::Printer;
use Getopt::Long::Descriptive qw( describe_options );
use List::Util qw( uniq );
use Path::Tiny qw( path );
use Pod::Usage qw( pod2usage );
use Try::Tiny qw( catch try );

my ( $opt, $usage ) = describe_options(
    'perlimports %o',
    [ 'filename|f=s', 'The file containing the imports', { required => 1 } ],
    [],
    [
        'ignore-modules=s',
        'Comma-separated list of modules to ignore.'
    ],
    [],
    [
        'ignore-modules-filename=s',
        'Path to file listing modules to ignore. One per line.'
    ],
    [],
    [
        'never-export-modules=s',
        'Comma-separated list of modules which do not export symbols.'
    ],
    [],
    [
        'never-export-modules-filename=s',
        q{Path to file listing modules which don't export symbols. One per line.}
    ],
    [],
    [ 'inplace-edit|i', 'edit the file in place' ],
    [],
    [
        'libs=s',
        'Comma-separated list of library paths to include (eg --libs lib,t/lib,dev/lib)',

    ],
    [],
    [
        'padding!',
        'pad imports: qw( foo bar ) vs qw(foo bar). Defaults to true',
        { default => 1 },

    ],
    [],
    [
        'read-stdin',
        'Read statements to process from STDIN rather than the supplied file',
    ],
    [],
    [],
    [ 'version',   'Print installed version', { shortcircuit => 1 } ],
    [ 'verbose|v', 'Print errors to STDERR' ],
    [ 'help',      "Print usage message and exit", { shortcircuit => 1 } ],
    [
        'verbose-help', "Print usage message and documentation ",
        { shortcircuit => 1 }
    ],
);

if ( $opt->help ) {
    print $usage->text;
    exit;
}

if ( $opt->verbose_help ) {
    print $usage->text;
    print pod2usage();
    exit;
}

if ( $opt->version ) {
    print $App::perlimports::VERSION;
    exit;
}

my $input;

if ( $opt->read_stdin ) {
    local $/;
    $input = <STDIN>;
}
else {
    $input = path( $opt->filename )->slurp;
}

my $doc = PPI::Document->new( \$input );

my $includes = $doc->find(
    sub {
        $_[1]->isa('PPI::Statement::Include');
    }
) || [];

if ( $opt->libs ) {
    unshift @INC, ( split m{,}, $opt->libs );
}

my @ignore_modules
    = $opt->ignore_modules
    ? split m{,}, $opt->ignore_modules
    : ();

if ( $opt->ignore_modules_filename ) {
    my @from_file
        = path( $opt->ignore_modules_filename )->lines( { chomp => 1 } );
    @ignore_modules = uniq( @ignore_modules, @from_file );
}

my @never_exports
    = $opt->never_export_modules
    ? split m{,}, $opt->never_export_modules
    : ();

if ( $opt->never_export_modules_filename ) {
    my @from_file
        = path( $opt->never_export_modules_filename )
        ->lines( { chomp => 1 } );
    @never_exports = uniq( @never_exports, @from_file );
}

my $pi_doc = App::perlimports::Document->new(
    filename => $opt->filename,
    @ignore_modules,
    @never_exports
    ? ( never_export_modules => \@never_exports )
    : (),
);

foreach my $include ( @{$includes} ) {
    my $e = App::perlimports->new(
        document => $pi_doc,
        @ignore_modules
        ? ( ignored_modules => \@ignore_modules )
        : (),
        include     => $include,
        pad_imports => $opt->padding,
    );

    my $elem;
    try {
        $elem = $e->formatted_ppi_statement;
    }
    catch {
        print STDERR 'Error: ' . $opt->filename . "\n";
        print STDERR $include;
        print STDERR $_;
    };

    next unless $elem;

    # https://github.com/adamkennedy/PPI/issues/189
    $include->insert_before( $elem->clone );
    $include->remove;

    if ( $opt->verbose && $e->has_errors ) {
        print STDERR 'Error: ' . $opt->filename . "\n";
        print STDERR $e->_module_name . ' ' . np( $e->errors ) . "\n";
    }
}

# We need to do this in order to preserve HEREDOCs.
# See https://metacpan.org/pod/PPI::Document#serialize
my $serialized = $doc->serialize;

if ( $opt->read_stdin ) {
    print $serialized;
}
elsif ( $opt->inplace_edit ) {
    path( $opt->filename )->spew($serialized);
}
else {
    print $serialized;
}

exit(0);

# PODNAME: perlimports
# ABSTRACT: A command line utility for cleaning up imports in your Perl code

=pod

=head1 SYNOPSIS

Update a file in place. (Make sure you can revert the file if you need to.)

    perlimports --filename test-data/foo.pl --inplace-edit

If some of your imported modules are in local directories, you can give some
hints as to where to find them:

    perlimports --filename test-data/foo.pl --inplace-edit --libs t/lib,/some/dir/lib

Redirect output to a new file:

    perlimports --filename test-data/foo.pl > foo.new.pl

Process all test files:

    find t -type f | grep .t$ | xargs -L 1 perlimports --libs lib,t/lib -i -v --ignore-modules Test::More -f

The above command finds all test files in C<./t> and pipes them to
C<perlimports>. C<lib> and C<t/lib> have been added to C<@INC>. The files are
edited in place (C<-i>). Verbose errors will be displayed and the L<Test::More>
module is ignored.

Process all lib files:

    find lib -type f | grep .pm$ | xargs -n 1 perlimports -i -v --libs lib -f

The above command finds all C<.pm> files in C<./t> and pipes them to
C<perlimports>. C<lib> has been added to C<@INC>. The files are edited in place
(C<-i>). Verbose errors will be displayed.

=head1 COMMAND LINE PARAMETERS

=head2 --filename|-f

The absolute or relative path to a file to process.

    --filename path/to/file

    -f path/to/file

=head2 --ignore-modules

A comma-separated list of module names which should be ignored by this script.
Any modules in this list should remain unchanged after processing.

    --ignore-modules Foo,Foo::Bar

=head2 --ignore-modules-filename

The absolute or relative path to a file which contains a lost of module names
to ignore. (See above for behaviour). The pattern is one module name per line.

    Foo
    Foo::Bar

=head2 --never-export-modules

A comma-separated list of module names which should never export symbols. If
these modules are found, we will ensure that they have an empty import list.
So, C<use Foo;> becomes C<use Foo ();>.

    --never-export-modules Foo,Foo::Bar

=head2 --never-export-modules-filename

The absolute or relative path to a file which contains a lost of module names
which should never export symbols. (See above for behaviour). The pattern is
one module name per line.

    Foo
    Foo::Bar

=head2 --inplace-edit|-i

Edit the file in place rather than printing the result to STDOUT. Make sure you
have a backup copy first.

    --inplace--edit
    -i

Edit the file in place rather than printing the result to STDOUT. Make sure you
have a backup copy first.

=head2 --[no-]padding

C<--padding> is enabled by default, so you only need to pass this arg if you
want to be explicit. This setting adds whitespace inside the parentheses.

    # --padding
    use Foo qw( bar baz );

The C<--no-padding> arg allows you to disable the additional padding inside
parentheses.

    # --no-padding
    use Foo qw(bar baz);

=head2 --libs

A comma separated list of module directories which are not in your C<@INC>

    --libs lib,t/lib

=head2 --read-stdin

Read statements to process from STDIN rather than processing the entire file.
This is intended for use by editors, like C<vim>. See the C<vim> heading below
for more information on how to set up an integration with your editor.

If this option is enabled, then C<--inplace-edit|-i> is not available.

    --read-stdin

=head2 --verbose|-v

Get verbose output. This will generally be the errors which were swallowed as
text was being processed.

    --verbose
    -v

=head2 --help

Output a concise help menu, with a summary of available parameters.

    --help

=head2 --verbose-help

Include the SYNOPSIS section from this page after printing the C<--help> menu
listed above.

=head2 VIM

If you're a C<vim> user, you can pipe your import statements to perlimports directly.

    :vnoremap <silent> im :!perlimports --read-stdin --filename '%:p'<CR>

The above statement will allow you to visually select one or more lines of code
and have them updated in place by C<perlimports>. Once you have selected the
code enter C<im> to have your imports (re)formatted.
