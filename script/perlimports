#!perl

# Does not work with modules using Sub::Exporter

use strict;
use warnings;

use FindBin qw( $Bin );
use lib "$Bin/../lib";

use App::perlimports ();
use Data::Printer;
use Getopt::Long::Descriptive qw( describe_options );
use Path::Tiny qw( path );
use Pod::Usage qw( pod2usage );
use Ref::Util qw( is_plain_arrayref );

my ( $opt, $usage ) = describe_options(
    'perlimports %o <some-arg>',
    [ 'filename|f=s', 'the file containing the imports', { required => 1 } ],
    [
        'ignored-modules=s',
        'comma-seperated list of modules to ignore (eg --ignored-modules Test::More,Test::Most'
    ],
    [ 'inplace-edit|i', 'edit the file in place' ],
    [
        'libs=s',
        'comma-seperated list of library paths to include (eg --libs lib,t/lib,dev/lib)',

    ],
    [
        'read-stdin',
        'read statements to process from STDIN rather than the supplied file',
    ],
    [],
    [ 'verbose|v',  'print errors to STDERR' ],
    [ 'help', "print usage message and exit", { shortcircuit => 1 } ],
);

if ( $opt->help ) {
    print $usage->text;
    print pod2usage();
    exit;
}

my $input;

if ( $opt->read_stdin ) {
    local $/;
    $input = <STDIN>;
}
else {
    $input = path( $opt->filename )->slurp;
}

my $doc = PPI::Document->new( \$input );

my $includes = $doc->find(
    sub {
        $_[1]->isa('PPI::Statement::Include');
    }
);

if ( $opt->libs ) {
    unshift @INC, ( split m{,}, $opt->libs );
}

if ( is_plain_arrayref($includes) ) {
    foreach my $include ( @{$includes} ) {
        my $e = App::perlimports->new(
            filename => $opt->filename,
            $opt->ignored_modules
            ? ( ignored_modules => [ split m{,}, $opt->ignored_modules ] )
            : (),
            include => $include,
            $opt->libs ? ( libs => [ split m{,}, $opt->libs ] ) : (),
        );

        my $elem = $e->formatted_ppi_statement;

        # https://github.com/adamkennedy/PPI/issues/189
        $include->insert_before( $elem->clone );
        $include->remove;

        if ( $opt->verbose && $e->has_errors ) {
            print STDERR $e->_module_name . ' ' . np( $e->errors );
        }
    }
}

# We need to do this in order to preserve HEREDOCs.
# See https://metacpan.org/pod/PPI::Document#serialize
my $serialized = $doc->serialize;

if ( $opt->read_stdin ) {
    print $serialized;
}
elsif ( $opt->inplace_edit ) {
    path( $opt->filename )->spew($serialized);
}
else {
    print $serialized;
}

exit(0);

# PODNAME: perlimports
# ABSTRACT: A command line utility for cleaning up imports in your Perl code

=pod

=head1 SYNOPSIS

Update a file in place. (Make sure you can revert the file if you need to.)

    perlimports --filename test-data/foo.pl --inplace-edit

If some of your imported modules are in local directories, you can give some
hints as to where to find them:

    perlimports --filename test-data/foo.pl --inplace-edit --libs t/lib,/some/dir/lib

Redirect output to a new file:

    perlimports --filename test-data/foo.pl > foo.new.pl

=head2 VIM

If you're a C<vim> user, you can pipe your import statements to perlimports directly.

    :vnoremap <silent> im :!perlimports --read-stdin --filename '%:p'<CR>

The above statement will allow you to visually select one or more lines of code
and have them updated in place by C<perlimports>. Once you have selected the
code enter C<im> to have your imports (re)formatted.
